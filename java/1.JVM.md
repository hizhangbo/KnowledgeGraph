# JVM
- JVM规范
  - Class文件格式
  - 运行时数据
  - 帧栈
  - 虚拟机的启动
  - 虚拟机的指令集
- JVM启动流程
  - java -jar xxx
  - 装载配置 jvm.cfg
  - 根据配置寻找 jvm.dll
  - 初始化jvm获取JNIEnv接口
  - 找到main方法并运行
- JVM基本结构
  - **类加载器**
  - **内存空间**
    - 方法区
    - 堆
    - 栈
    - 本地方法栈(native)
  - **垃圾收集器**
  - PC寄存器
  - 执行引擎
  - 本地方法接口
  - 本地方法库
- PC寄存器
  - 每一个线程拥有一个PC寄存器
  - 在线程创建时创建
  - 指向下一条指令的地址
  - 执行本地方法时，PC的值为undefined
- 方法区
  - 保存装载的类信息
    - 类型的常量池
    - 字段，方法信息
    - 方法字节码
  - 通常和永久区Perm关联在一起（java8以后PermGen被Metaspace替代）
    - 元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存
- 堆
  - 对象存储
  - 所有线程共享
  - 对分代GC来说，堆也是分代的
    - eden
    - s0
    - s1
    - tenured
  - GC的主要工作区间
- 栈
  - 线程私有
  - 栈由一系列帧组成
  - 帧保存一个方法的局部变量表、操作数栈、常量池指针
  - 每一次方法调用创建一个帧，并压栈
  - 栈上分配
    - 小对象（几十bytes），在没有逃逸的情况下
    - 大对象或者逃逸对象无法栈上分配
      - 逃逸指非线程私有
    - 启动参数增加-XX:+DoEscapeAnalysis，减少GC(-XX:PrintGC)
- JVM内存拷贝
  - 每一个线程有一个工作内存和独立主存
  - 工作内存存放主存中变量的值的拷贝
  - volatile 关键字可以使JMM将工作内存中的改变及时同步到主存中
    - 可见性
      - 其他可见性关键字
        - synchronized
        - final
    - 有序性
      - 一个线程内的操作都是有序的
      - 在该线程外观察操作是无序的（指令重排/主内存同步延时）
    - 指令重排
      - 没有语义冲突有可能被重排
      - 编译器不考虑多线程间的语义，如果要保证顺序使用synchronized
- JVM常用配置
  - Trace跟踪参数
    - -Xloggc:log/gc.log
    - -XX:+PrintHeapAtGC
    - -XX:+TraceClassLoading
    - -XX:+PrintClassHistogram (ctrl+break 触发打印类的使用情况)
    - -verbose:gc
    - -XX:+printGC
    - -XX:+printGCDetails
    - -XX:+printGCTimeStamps # 打印GC发生的时间戳
      - new generation
        - eden space
        - from space
        - to space
      - tenured generation
      - compacting perm gen
      - ro space
      - rw space
  - 堆的分配参数
    - 参数类型
      - 标配参数
        - java -version
      - X 参数
        - -Xint 解释执行
        - -Xcomp 第一次使用就编译成本地代码
        - -Xmixed 混合模式，编译执行
      - XX 参数
    - 总体配置
      - Xms
      - Xmx
        - 设置相同，防止抖动
    - 新生代
      - -Xmn (新生代)
      - -XX:NewRatio （新生代和老年代的比值）
      - 幸存代
        - XX:SurvivorRatio （Survivor和eden的比值）
    - OOM时触发
      - -XX:+HeapDumpOnOutOfMemoryError
      - -XX:+HeapDumpPath
  - ~~PermGen参数~~（java8 中已废弃）
    - -XX:PermSize
    - -XX:MaxPermSize
  - 栈的分配参数
    - Xss
      - 通常几百K
      - 决定函数调用深度
  - 常量池
    - class文件常量池
      - class文件常量池位于class文件中
    - 运行时常量池
      - 当类或接口创建时，它的class中的常量池会被用来构造运行时常量池，常量池中的符号引用会被解析成具体的内存地址。运行时常量池是jvm方法区的一部分，它可以在运行时将符号引用解析为直接引用。
      - 运行时常量池位于jvm的元空间中(java8)
    - 字符串常量池
      - 字符串常量池底层实现是一个哈希表，可以通过-XX:StringTableSize参数调整大小。字符串常量池中存储的是字符串对象的引用，而字符串本身是在堆上分配的(java中的对象基本都在堆上分配)。运行时常量池初始化的时候，字面量的符号引用的初始化会用到字符串常量池。String中的intern方法可以在运行时将字符串实例加入字符串常量池。
      - 在java1.7以前，字符串常量池是在堆的永久代里面，大小固定，而从java1.7以后，字符串常量池则移动到java堆中了。
- GC
  - 算法
      - 引用计数法
        - 循环引用导致内存泄露
      - 标记清除
        - 从根节点标记可达引用对象，其余不可达的对象全部清除
      - 标记压缩
        - 在标记清除基础上，压缩可达对象空间
      - 复制算法
        - 两块大小相同的内存，第一块内存空间中所有存活对象被复制到另外一块中，然后对第一块进行清理
        - 每次复制清除后，第一块和第二块内存空间角色对调
        - 空间较为浪费，只存放小对象
      - 分代思想
        - 新生代
          - 少量较小对象存活，适合复制算法
        - 老年代
          - 大量对象存活，或较大对象，适合标记清除/标记压缩算法
  - 可触及性
    - 可触及
    - 不可触及
    - 可复活
      - 重写对象的finalize方法，只会被调用一次，避免使用
    - 根节点
      - 栈中引用的对象
      - 方法去中静态成员/常量引用对象
      - JNI方法栈中引用对象
  - Stop-The-World
    - JVM中全局暂停
      - Dump线程
      - 死锁检查
      - 堆Dump
  - GC 参数
    - -XX:MaxGCPauseMills
      - GC最大停顿时间
    - -XX:GCTimeRatio
      - 单位时间内应用的GC使用CPU占比
    - 串行回收器
      - -XX:+UseSerialGC
      - 单线程回收
      - 新生代复制算法
      - 老年代标记压缩算法
    - 并行回收器
      - ParNew
          - -XX:+UseParNewGC
            - 新生代并行
            - 老年代串行
          - -XX:ParallelGCThreads 限制线程数量
      - Parallel
        - -XX:+UseParallelGC
        - -XX:+UseParallelOldGC
        - 增加吞吐量
    - CMS回收器（老年代）
      - -XX:+UseConcMarkSweepGC
        - 并发标记清除
        - 和应用程序一起进行
        - 减少停顿时间
        - 减少吞吐量
      - -XX:+UseCMSCompactAtFullCollection
      - -XX:+CMSFullGCsBeforeCompaction
      - -XX:ParallelCMSThreads
      - 过程
        - 初始标记
          - 根可达对象，速度快，单独进行
        - 并发标记
          - 主要标记过程，和应用程序进程一起进行
        - 重新标记
          - 在并发标记时，应用产生的垃圾进行标记，单独进行
        - 并发清理
          - 清理垃圾对象，和应用程序进程一起进行
      - 碎片
        - 标记清除产生内存碎片
        - 
  - GC Roots 判断引用可达
    - 栈中引用的对象（局部变量表）
    - 方法区中的类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI（Native方法）引用的对象
- ClassLoader 类装载器
  - 抽象类
    - loadClass
    - defineClass
    - findClass
    - findLoadedClass
  - 分类
    - BootStrap ClassLoader  -> rt.jar /-Xbootclasspath
      - -Xbootclasspath/a:/var/lib
    - Extension ClassLoader -> %JAVA_HOME%/lib/ext/*.jar
    - App ClassLoader -> classpath
    - Custom ClassLoader
  - 过程
      - 加载(双亲模式)
        - 自底向上检查类是否已经加载
        - 自顶向下尝试加载类
        - 类的二进制流，转为方法区数据结构，生成对应的java.lang.Class对象
      - 链接
        - 验证
          - 文件格式
          - 元数据
          - 字节码
        - 准备
          - 分配内存，并为类设置初始化方法区
        - 解析
          - 符号引用替换直接引用
      - 初始化
        - 执行类构造器 **clinit**
          - static变量 赋值语句
          - static{}静态代码块
        - 子类的**clinit**调用前一定保证父类的**clinit**已被调用
- 性能监控
  - 系统性能监控
    - uptime
    - vmstat
    - pidstat
  - jdk自带工具
    - 命令行
        - jps -lv
        - jinfo -flag # 查看jvm启动参数
          - jinfo -flags pid
        - jmap -histo pid # 类对象使用情况
        - jstack pid 
        - jstatus
    - 图形化
        - JConsole
        - Visual VM
  - OOM
    - MAT
      - 浅堆
        - 一个对象结构所占用的内存大小，元数据大小
      - 深堆
        - 一个对象被GC后，可是真是释放的内存大小，对象大小
- 锁
  - 对象头Mark，32位
    - 描述对象的hash，索信息，垃圾回收标记，年龄
  - 偏向锁/可重入锁
    - -XX:+UseBiasedLocking
    - 已获得锁的线程，只要没有竞争，在将来进入同步块时不需要做同步
  - 轻量级锁
    - 存放在线程栈中
    - 如果有竞争，就会升级为重量级锁
  - 自旋锁
    - 存在竞争时，线程做几个空操作，不使用系统挂起
  - Jvm获取锁的优先级
    - 先获取偏向锁 -> 轻量级锁 -> 自旋锁
  - 锁的优化
    - 减少锁的持有时间
    - 减小锁粒度
      - ConcurrentHashMap
        - 由若干个Segment组成
        - 每个Segment中维护HashEntry
        - 在并发操作时，锁定一个Segment
    - 锁粗化
      - 锁的请求非常频繁时，可以将操作合并在同一个锁中
    - 锁消除
      - -server -XX:+DoEscapeAnalysis -XX:+EliminateLocks
    - 锁分离
      - |类型|读锁|写锁|
        |----|----|----|
        |读锁|可访问|不可访问|
        |写锁|不可访问|不可访问|
    - CAS
      - 乐观锁
      - Compare And Swap
      - CAS(V,E,N) V要更新的变量，E期望当前值，N新值
      - AtomicInteger 中getAndSet使用CAS
- Class文件结构
  - magic
  - 小版本号
  - 大版本号
  - 常量池
  - 访问标识符
  - 接口
  - 字段
  - 方法
  - attribute
- 字节码对照
  - ASM 实现AOP
    - ClassVisitor
- JIT及其相关参数
  - -XX:CompileThreshold=1000
  - -XX:+PrintCompilation
  - Xint # 解释执行
  - Xcomp # 编译执行
  - Xmixed # 混合，默认
- 引用分类及GC
  - 强引用 Reference
    - 默认
  - 软引用 SoftReference
    - 内存够用就保留，内存不够用就回收
  - 弱引用 WeakReference
    - 只要GC进行就会被回收
    - WeakHashMap
      - 缓存
  - 虚引用 PhantomReference
    - 在任何时候都可能被垃圾回收器回收
    - ReferenceQueue 在GC时放到引用队列
    - finalize()方法
- Throwable
  - Exception
    - RuntimeException
  - Error
    - StackOverflowError # 递归深度调用
    - OutOfMemoryError
      - Java heap space # 对象过多
      - GC overhead limit exceeded # GC占用80%资源回收，但效果不明显，则抛出
      - Direct buffer memory # NIO
      - unable to create new native thread # 线程创建太多
      - Metaspace # 
  
  
  
  
  
  
  
  
  
  